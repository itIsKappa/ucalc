#! /usr/bin/python3

# UCalc © 2020 Hathim Ali
# Distributed under GNU GPL v3

# If you are running this program from the folder itself
# rather moving it into /usr/bin or running it after 
# installing it using the deb package or install.sh,
# it is strongly adviced that you may run it
# not by 'python3 ucalc' but './ucalc'

interactive = False

def main():
    try:
        import sys
        import os
        from time import ctime
        from time import time
        import math
        import readline

        starting_time = time()
        global interactive
        global log
        if not interactive:
            log = f"{ctime()}\n"
        else:
            log += f"{ctime()}\n"
        
        path_to_log = "ucalcLog.txt" 
        path_to_f = "./f"
        path_to_f_c = "f.c"
        path_to_xy = "./xy"
        path_to_xy_c = "xy.c"
        version = "v4.3"

        version_view = f"""
UCalc © 2020 HathimAli
Stable Version
UCalc {version}
     """

        about_view = """
======================= 
     A  B  O  U  T        
=======================
UCalc © 2020 HathimAli
UCalc is distributed under GNU General Public License v3.
See the GNU GPL documentation provided with this program
or reach the web.
UCalc is a command-line-interface calculator supplied with rich features.
Any means of crashing, hopes to be reported by the user.
Users can mail to the address -- honeyt2019@gmail.com
It is a best practice to include the ucalcLog.txt to be
found at /usr/share/ucalc 
========================
"""
        help_view = f"""
Usage:
ucalc [expression]
ucalc [option]

=====================
E X P R E S S I O N S
=====================
-----------------------
   O P E R A T O R S
-----------------------
UCalc supports all arithmetic operators:
+ for addition
- for subtraction
x or * for multiplication
/ for division but returns quotient
% for division but returns remainder
^ for raising to the power
-------------------------
UCalc has made arithmetic operators intuitive.
Usage of x rather than * for multiplication is encouraged.
* may have to be preceded by \\ to escape * as it is a special character.
So, it is faster and less to write 8x4 rather than 8\\*4.
-------------------------
     B R A C K E T S       
-------------------------
UCalc also supports brackets, two kinds to be exact;
the curly brackets and the square brackets.
Though, it must be noted that nested brackets of same kind
will confuse UCalc and may reply erroneously or may not even reply.
There cannot be square brackets inside square brackets but curly brackets.
Exempli gratia, 2+[2x[5+5]] is wrong and UCalc will most likely err
while 2+[2+{"{5+5}"}] is the best practice and will yield correct answers.
---------------------------------------------------------------------------
   F A C T O R I A L S,  S Q U A R E R O O T S  A N D  C U B E R O O T S
---------------------------------------------------------------------------
Factorials:
    There are two ways to tell UCalc to find a number's factorial.
    First is to add "!" to ending of a number.
    Though, you may have add a  backslash before the exclamation mark
    as it is a special character.
    Another, will be to add "?" to ending of a number as it avoids
    having to enter a backslash everytime before you type an
    exclamation mark.
    Exempli gratia, 5\\! will return 120, but, ?5 also returns 120 and it is
    lesser to write.
    Again, [3\\!]\\! will return 720, but, there is backslashes two
    times and your inputs becomes less readable and understandable to
    [3?]?, wherein one can quickly read and understand the expression,
    in both, UCalc can read your input and return an answer.

Square-roots:
    Akin to factorial, there are two ways for you when you want get the
    square root of a number. Reason for being provided with two ways
    is similar to factorial.
    First is to use the actual square root symbol or "√".
    It is not available in every in keyboard layout and thus calls
    for a better and easier way.
    The better way is to, use an underscore or "_".
    Exempli gratia, _25 will return 5
               _[64+46] will return 10
               If you try finding square root of a number that is
               not a square, like,
               _2 then, UCalc will return 1.4142135623730951

Cube-roots:
    Fortunately and unfortunately, there is only way in which you can
    find the cube root of number and that is to add a colon or ":"
    to the beginning like you have done as in above cases.
    Exempli gratia, :27 will give 3

---------------------
    F A C T O R S      
---------------------
UCalc also provides for fetching factors of a given number.
Similar to the many extra inputs, which happens to be mentioned
below extra inputs section, the number is to end with either
'.factor' or '.f'
Exempli gratia, 4.factor wil return 1, 2, 4
We can also do arithmetic operation before finding the factors,
2+2.factor will return 1, 2, 4

---------------------------------------------
    P R O D U C T - S U M   F A C T O R S   
---------------------------------------------
UCalc is shipped with XY, a product-sum factor finder.
Since, XY requires, at the least, three inputs, which they
are will be told further down, the method of calling used is
known as the Double-Colon-Call. First, you have to enter
the type of Double-Colon function you are calling, here,
it is the product-sum factor finder, which has, undoubtedly,
the name 'xy'. XY requires three arguments and no more.
They are, with respect to order, the product, the sum and
the counter. The product and the sum are obvious but the counter
may not be. The counter determines upto how much to count to
beginning from one.
Exempli gratia,
xy::100::25::100 will return 20 and 5.
Since, the larget among the result is 20, all the numbers
thence was unnecassary even though the XY will stop when
it finds a factor. Now here,
xy::100::25::10, will not return a factor since it is 
larger than the counter specified.
Above, we have called XY and immediately entered
double-colons and every argument has to be separated by
double colons, hence, the name Double-Colon-Call.

=====================================
R U L E S  O F  C A L C U L A T I O N
=====================================
UCalc, by default and implicitly, uses the rule of BODMAS.
It can also use the rule of precedence though it has to be explicitly
mentioned as it falls under the category of extra inputs.
Thus, an expression followed by '.precede' will prompt UCalc to use
the rule of precedence.
Exempli gratia, 5-4x2 will return -3, but,
5-4x2.precede will return 2

============================
N E G A T I V E  V A L U E S
============================
Negating a value in UCalc is simple.
You should add ~ to the beginning of the number.
Exempli gratia, 2--2 or 2-[-2] is wrong and it will cause errors.
           2-~2 is the right way and will return the aniticipated value,
           id est, 0
Simply a minus sign is considered an arithmetic operator to UCalc,
if only a value begins with ~, UCalc will consider it negative.

======================
E X T R A  I N P U T S
======================
Some extra inputs have been predefined for UCalc which affects the result
of the calculation. All extra inputs are akin to how you have to mention
to UCalc to use the rule of precedence rather than BODMAS (If you have
not read about it, it is aforementioned under the section--
"RULES OF CALCULATION"), all extra inputs begin with a period or ".".
The extra inputs are as follows:
    round - estimately rounds the result, if it is a floating point
            number.
            Exempli gratia, 5/2 will return 2.5, but,
            5/2.round will return simply 2
    
    ceil - rounds the result but to the nearest highest value to
           the result ('ceiling' is shortened to 'ceil').
           Exempli gratia, 5/2.round will return 2 , but,
           5/2.ceil will return 3.

    floor - rounds the result but to the nearest lowest value to 
            the result ('floor' is contrary to 'ceil'/'ceiling').
            Exempli gratia, 5/3 will return 1.6666666666666667, but,
            5/3.floor will return 1 on the other hand, if you are
            to use '.round', then, the answer will be 2 for the
            result is evidently above 1.5, so, as the estimation will
            be to round to the nearest value the result is such,
            id est, 2.
===================
C O N V E R T E R S
===================
UCalc also has some built-in base converters. Like extra inputs,
the converters will convert the final value and display it to you.
And also, again like extra inputs, these also have to be preceded with
period or '.'.
The converters are as follows:

    bin - converts the result to binary/base-2.

    ter - converts the result to ternanray/base-3.

    oct - converts the result to octal/base-8.

    hex - converts the result to hexadecimal/base-16.

    base64 - converts the result to base64.

Base-64 converter has to be used with caution as it is custom made for
UCalc and value representation may differ heavily with other converters
and thus, it may no be reverse convertible with other converters, though,
UCalc also has built-in reverse converters for all of the above converters.
Converter will accept floating point values or a number that contains Euler's.
The best way to such is to use round, ceil or floor extra input with the
converters.

----------------------------------------
   R E V E R S E  C O N V E R T E R S
----------------------------------------
Everything is as above except the names to invoke these converters differ.
The reverse converters are as follows:

    frombin - converts the given value from binary to decimal.

    fromter - converts the given from ternary to decimal.

    fromoct - converts the given value from octal to decimal.

    fromhex - converts the given value from hexadecimal to decimal.

    from64 - converts the given the value from base-64 to decimal.

It is upon you that you should not include other than 1 or 0 in
reverse binary converter, nothing but between 0 - 7 in
octal converter and between 0 - 3 in ternary converter
for even if you are to enter wrong values to
binary, octal and ternary converters, they will tolerate
and return a wrong value. Where as hexadecimal and base-64 reverse
converters will not tolerate and excuse that they have been given a
non-convertible value. 
 
||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

========================
     O P T I O N S
========================

--help or -h - brings about what you are seeing.

--about or -ab - brings about more information about licensing
                 and the program.

--version or -v - brings about information about the version of the
                  program that you are currently running.

--constants or -c - brings about the list containing constants supported
                    by UCalc {version}

-L - shows the log of last calculation using "less" utility in Linux.

-Lv - dumps the log of last calculation into terminal or standard out.

========================
||||||||||||||||||||||||| UCalc © 2020 HathimAli |||||||||||||||||||||||||
"""
        constant_view = f""" 
===================
 C O N S T A N T S
===================

UCalc is packed with a few constants which avails you from typing 
specific values everytime and makes UCalc less verbose.
Exempli gratia, rather than entering 2x22/7x7,
           you can enter 2xpix7 and it returns 44 

Constants supported by UCalc {version} are as follows:

    pi - it stands for Pi, can also use the greek letter "π" for Pi
    
    g - it stands for Earth's gravity

    G - it stands for the Universal Gravitational Constant

    R - it stands for the Gas Constant

    h - it stands for Planck's Constant

    N - it stands for Avogadro's Number

    C - it stands for Speed of Light in Vacuum

    F - it stands for Faraday Constant

    k - it stands for Boltzmann Constant

====================
    """
        i_help_view = f"""
=======================================
I N T E R A C T I V E  M O D E  H E L P
=======================================
Rules and functionality are same as simply evoking UCalc.
There are some special input for using interactive mode
and they are as follows:
    
    quit - quit interactive mode

    about - brings about more information about UCalc

    version - brings about the current version you are running

    help - brings about a helpful guide on how to use UCalc

    constants - brings about the list containing all constants
                supported by UCalc {version}
---------------------------------------
Since you are not in a terminal, special characters like
"!" and "*" will not be a issue.

[ NOTE ]
OPTIONS DO NOT REQUIRE HYPHENS BEFORE THEM IN INTERACTIVE MODE!
---------------------------------------
        """

        class Converters():

            def error_correction(self, number):
                number = str(number)
                if "." in number or "e" in number:
                    exit("UCalc Excuses: Cannot convert numbers with floating value or Euler's.")

            def reverse_ternary(self, num):
                def middle(num):
                    value = 0
                    items = []
                    for each in num:
                        items.append(each)
                    items.reverse()
                    nos = len(items)
                    for each in range(nos):
                        items[each] = int(items[each])
                    for each in range(nos):
                        value += 3 ** each * items[each]
                    return value

                num = num.split(" ")
                toAppend = ""
                for each in num:
                    each = middle(each)
                    each = str(each)
                    toAppend += each + " "
                return toAppend

            def reverse_hexadecimal(self, num):
                hex_alpha_values = {
                    "A": 10,
                    "B": 11,
                    "C": 12,
                    "D": 13,
                    "E": 14,
                    "F": 15,
                }

                def middle(num):
                    value = 0
                    items = []
                    for each in num:
                        items.append(each)
                    items.reverse()
                    nos = len(items)
                    for each in range(nos):
                        each = int(each)
                        each_value = hex_alpha_values.get(items[each], items[each])
                        try:
                            each_value = int(each_value)
                        except ValueError:
                            exit("UCalc Excuses: Input does not appear to be hexadecimal value.")
                        value += 16 ** each * each_value
                    return value

                num = num.split(" ")
                to_append = ""
                for each in num:
                    each = middle(each)
                    each = str(each)
                    to_append += each + " "
                return to_append

            def reverse_binary(self, num):
                def middle(num):
                    value = 0
                    items = []
                    for each in num:
                        items.append(each)
                    items.reverse()
                    nos = len(items)
                    for each in range(nos):
                        items[each] = int(items[each])
                    for each in range(nos):
                        value += 2 ** each * items[each]
                    return value

                num = num.split(" ")
                to_append = ""
                for each in num:
                    each = middle(each)
                    each = str(each)
                    to_append += each + " "
                return to_append.strip()

            def reverse_octal(self, num):
                def middle(num):
                    value = 0
                    items = []
                    for each in num:
                        items.append(each)
                    items.reverse()
                    nos = len(items)
                    for each in range(nos):
                        items[each] = int(items[each])
                    for each in range(nos):
                        value += 8 ** each * items[each]
                    return value

                num = num.split(" ")
                to_append = ""
                for each in num:
                    each = middle(each)
                    each = str(each)
                    to_append += each + " "
                return to_append

            def reverse_base64(self, num):
                hex_alpha_values = {
                     "A": 10,
                     "B": 11,
                     "C": 12,
                     "D": 13,
                     "E": 14,
                     "F": 15,
                     "G": 16,
                     'H': 17,
                     "I": 18,
                     "J": 19,
                     "K": 20,
                     "L": 21,
                     "M": 22,
                     "N": 23,
                     "O": 24,
                     "P": 25,
                     "Q": 26,
                     "R": 27,
                     "S": 28,
                     "T": 29,
                     "U": 30,
                     "V": 31,
                     "W": 32,
                     "X": 33,
                     "Y": 34,
                     "Z": 35,
                     "a": 36,
                     "b": 37,
                     "c": 38,
                     "d": 39,
                     "e": 40,
                     "f": 41,
                     "g": 42,
                     "h": 43,
                     "i": 44,
                     "j": 45,
                     "k": 46,
                     "l": 47,
                     "m": 48,
                     "n": 49,
                     "o": 50,
                     "p": 51,
                     "q": 52,
                     "r": 53,
                     "s": 54,
                     "t": 55,
                     "u": 56,
                     "v": 57,
                     "w": 58,
                     "x": 59,
                     "y": 60,
                     "z": 61,
                     "-": 62,
                     "_": 63,
                }
                def middle(num):
                    value = 0
                    items = []
                    for each in num:
                        items.append(each)
                    items.reverse()
                    nos = len(items)
                    for each in range(nos):
                        each = int(each)
                        each_value = hex_alpha_values.get(items[each], items[each])
                        each_value = int(each_value)
                        value += 64 ** each * each_value
                    return value

                num = num.split(" ")
                to_append = ""
                for each in num:
                    each = middle(each)
                    each = str(each)
                    to_append += each + " "
                return to_append

            def ternary(self, number):
                Converters().error_correction(number)
                number = number.split(" ")
                valum_final = ''
                for num in number:
                    item = []
                    try:
                        num = int(num)
                    except ValueError:
                        break
                    while True:
                        valum_finale = ''
                        value = num // 3
                        value2 = num % 3
                        item.append(value2)
                        num = value
                        if num == 0:
                            item.reverse()
                            for each in item:
                                valum_finale += each.__str__()
                            valum_final += valum_finale + " "
                            break
                        else:
                            pass
                return valum_final

            def hexadecimal(self, number):
                Converters().error_correction(number)
                hex_strings = {
                    10: "A",
                    11: "B",
                    12: "C",
                    13: "D",
                    14: "E",
                    15: "F",
                }
                number = number.replace("-", "")
                number = number.split(" ")
                valum_final = ''
                for num in number:
                    item = []
                    try:
                        num = int(num)
                    except ValueError:
                        break
                    while True:
                        valum_finale = ''
                        value = num // 16
                        value2 = num % 16
                        value2 = hex_strings.get(value2, value2)
                        item.append(value2)
                        num = value
                        if num == 0:
                            item.reverse()
                            for each in item:
                                valum_finale += each.__str__()
                            valum_final += valum_finale + " "
                            break
                        else:
                            pass
                return valum_final

            def binary(self, number):
                Converters().error_correction(number)
                number = number.replace("-", "")
                number = number.split(" ")
                valum_final = ''
                for num in number:
                    item = []
                    try:
                        num = int(num)
                    except ValueError:
                        break
                    while True:
                        valum_finale = ''
                        value = num // 2
                        value2 = num % 2
                        item.append(value2)
                        num = value
                        if num == 0:
                            item.reverse()
                            for each in item:
                                valum_finale += each.__str__()
                            valum_final += valum_finale + " "
                            break
                        else:
                            pass
                return valum_final

            def octal(self, number):
                Converters().error_correction(number)
                number = number.replace("-", "")
                number = number.split(" ")
                valum_final = ''
                for num in number:
                    item = []
                    try:
                        num = int(num)
                    except ValueError:
                        break
                    while True:
                        valum_finale = ''
                        value = num // 8
                        value2 = num % 8
                        item.append(value2)
                        num = value
                        if num == 0:
                            item.reverse()
                            for each in item:
                                valum_finale += each.__str__()
                            valum_final += valum_finale + " "
                            break
                        else:
                            pass
                return valum_final

            def base64(self, number):
                Converters().error_correction(number)
                base_sixty_four_strings = {
                    10: "A",
                    11: "B",
                    12: "C",
                    13: "D",
                    14: "E",
                    15: "F",
                    16: "G",
                    17: 'H',
                    18: "I",
                    19: "J",
                    20: "K",
                    21: "L",
                    22: "M",
                    23: "N",
                    24: "O",
                    25: "P",
                    26: "Q",
                    27: "R",
                    28: "S",
                    29: "T",
                    30: "U",
                    31: "V",
                    32: "W",
                    33: "X",
                    34: "Y",
                    35: "Z",
                    36: "a",
                    37: "b",
                    38: "c",
                    39: "d",
                    40: "e",
                    41: "f",
                    42: "g",
                    43: "h",
                    44: "i",
                    45: "j",
                    46: "k",
                    47: "l",
                    48: "m",
                    49: "n",
                    50: "o",
                    51: "p",
                    52: "q",
                    53: "r",
                    54: "s",
                    55: "t",
                    56: "u",
                    57: "v",
                    58: "w",
                    59: "x",
                    60: "y",
                    61: "z",
                    62: "-",
                    63: "_",
                }
                number = number.replace("-", "")
                number = number.split(" ")
                valum_final = ''
                for num in number:
                    item = []
                    try:
                        num = int(num)
                    except ValueError:
                        break
                    while True:
                        valum_finale = ''
                        value = num // 64
                        value2 = num % 64
                        value2 = base_sixty_four_strings.get(value2, value2)
                        item.append(value2)
                        num = value
                        if num == 0:
                            item.reverse()
                            for each in item:
                                valum_finale += each.__str__()
                            valum_final += valum_finale + " "
                            break
                        else:
                            pass
                print("UCalc warns: This base sixty four conversion may not be reverse convertible in other programs."
                        "\n ***** same conversion values used by YouTube's video identities  *****")
                return valum_final


        def safety_formatting(string):
            string = string.strip()
            string = string.replace("_ ", "_")
            string = string.replace(" _ ", "_")
            string = string.replace(" - ", "substitute_text")
            string = string.replace("- ", "-")
            string = string.replace("substitute_text", " - ")
            string = string.replace("--", "+")
            string = string.replace(" ?", "?")
            string = string.replace(" !", "!")
            return string
        
        def cube_root(num):
            global log
            with open(path_to_log, "w") as file:
                        file.write(log)
            num = num.replace(":", "")
            try:
                num = int(num)
            except ValueError:
                exit(f"UCalc Excuses: Some non-calculable value('{num}') has been given to me.")
            value = math.ceil(num ** 0.333333333333333)
            return value.__str__()

        def factorial(num):
            global log
            """ The original factorial finder has been
                made common to act as a fallback """
            log += f"{num}"
            with open(path_to_log, "w") as file:
                file.write(log)
            num = num.replace("?", "")
            num = num.replace("!", "")
            try:
                num = int(num)
            except ValueError:
                try:
                    num = float(num)
                except ValueError:
                    exit(f"UCalc Excuses: Some non-calculable value('{num}') has been given to me.")

            # Fallback # factorial_list = [1]
            # Fallback # factorial_value = 1
            # Fallback # while num != 0:
            # Fallback #     factorial_list.append(num)
            # Fallback #     num = num - 1
            # Fallback # for each in factorial_list:
            # Fallback #     factorial_value *= each
            # Fallback # return factorial_value.__str__()

            try:
                return math.factorial(num).__str__()
            except ValueError:
                exit(f"""
    UCalc Excuses:
        Some expression in your input resulted in a floating point value and that value called to find its factorial.
        Finding factorial of floating point values is impossible for me; It might result in an infinite loop,
        where your machine might not respond.
        Your resultant number before calling for finding factorial is {num}
    """)


        def square_root(num):
            num = num.replace("_", "")
            num = num.replace("√", "")
            try:
                num = int(num)
            except ValueError:
                try:
                    num = float(num)
                except ValueError:
                    exit(f"UCalc Excuses: Some non-calculable value('{num}') has been given to me.")
            return math.sqrt(num).__str__()

        def calculator_bodmas(num):
            global log
            some_list = num.split(" ")
            to_be_num_string = ""
            for each in range(len(some_list)):
                if "?" in some_list[each] or "!" in some_list[each]:
                    some_list[each] = factorial(some_list[each])
                    log += f"Factorial: {args}\n"
                elif some_list[each].startswith("_") or some_list[each].startswith("√"):
                    some_list[each] = square_root(some_list[each])
                    log += f"SquareRoot: √{args}\n"
                elif some_list[each].startswith(":"):
                    some_list[each] = cube_root(some_list[each])
                    log += f"CubeRoot: {args}\n"
                with open(path_to_log, "w") as file:
                    file.write(log)

            for each in some_list:
                to_be_num_string += each + " "
            to_be_num_string = to_be_num_string.strip()
            log += f"to_be_num: {to_be_num_string}\n"
            num = to_be_num_string

            # RaiseTo / PowerOf #############################
            pow_split = num.split(" ^ ")
            log += f"^^^{pow_split}\n"
            for i in range(len(pow_split)):
                pow_split[i] = pow_split[i].strip()
                pow_split[i] = pow_split[i].replace("~", "-")

            log += f"{pow_split}\n"
            while len(pow_split) != 1:
                one_value_list = pow_split[0].split(" ")
                two_value_list = pow_split[1].split(" ")

                try:
                    one_value_list.remove("")
                    two_value_list.remove("")
                except ValueError:
                    pass

                try:
                    one_value = int(one_value_list[-1])
                    two_value = int(two_value_list[0])
                except ValueError:
                    one_value = float(one_value_list[-1])
                    two_value = float(two_value_list[0])

                pow_value = one_value ** two_value
                two_value_list.remove(two_value_list[0])

                one_value_list[-1] = pow_value.__str__()
                some_string = ""
                for each in one_value_list:
                    some_string += each + " "
                for each in two_value_list:
                    some_string += each + " "
                some_string = some_string.strip()

                log += f"{pow_split}\n"
                pow_split.remove(pow_split[0])
                pow_split.remove(pow_split[0])
                pow_split.insert(0, some_string)
            else:
                num = pow_split[0]

            # Division ################################
            div_split = num.split(" / ")
            log += f"///{div_split}\n"

            for i in range(len(div_split)):
                div_split[i] = div_split[i].strip()
                div_split[i] = div_split[i].replace("~", "-")

            log += f"{div_split}\n"
            while len(div_split) != 1:
                one_value_list = div_split[0].split(" ")
                two_value_list = div_split[1].split(" ")

                try:
                    one_value_list.remove("")
                    two_value_list.remove("")
                except ValueError:
                    pass

                try:
                    one_value = int(one_value_list[-1])
                    two_value = int(two_value_list[0])
                except ValueError:
                    one_value = float(one_value_list[-1])
                    two_value = float(two_value_list[0])
                try:
                    div_value = one_value / two_value
                except ZeroDivisionError:
                    exit("UCalc Excuses: Cannot divide by zero.")

                two_value_list.remove(two_value_list[0])

                one_value_list[-1] = div_value.__str__()
                some_string = ""
                for each in one_value_list:
                    some_string += each + " "
                for each in two_value_list:
                    some_string += each + " "
                some_string = some_string.strip()

                log += f"{div_split}\n"
                div_split.remove(div_split[0])
                div_split.remove(div_split[0])
                div_split.insert(0, some_string)
            else:
                num = div_split[0]

            # Remainder / Modulus ############################
            modulus_split = num.split(" % ")
            log += f"%%%{modulus_split}\n"
            log += f""
            for i in range(len(modulus_split)):
                modulus_split[i] = modulus_split[i].strip()
                modulus_split[i] = modulus_split[i].replace("~", "-")

            log += f"{modulus_split}\n"
            while len(modulus_split) != 1:
                one_value_list = modulus_split[0].split(" ")
                two_value_list = modulus_split[1].split(" ")

                try:
                    one_value_list.remove("")
                    two_value_list.remove("")
                except ValueError:
                    pass

                try:
                    one_value = int(one_value_list[-1])
                    two_value = int(two_value_list[0])
                except ValueError:
                    one_value = float(one_value_list[-1])
                    two_value = float(two_value_list[0])

                modulus_value = one_value % two_value
                two_value_list.remove(two_value_list[0])

                one_value_list[-1] = modulus_value.__str__()
                some_string = ""
                for each in one_value_list:
                    some_string += each + " "
                for each in two_value_list:
                    some_string += each + " "
                some_string = some_string.strip()

                log += f"{modulus_split}\n"
                modulus_split.remove(modulus_split[0])
                modulus_split.remove(modulus_split[0])
                modulus_split.insert(0, some_string)
            else:
                num = modulus_split[0]

            # Multiplication ###############################
            num = num.replace("*", "x")
            multi_split = num.split(" x ")
            log += f"***{multi_split}\n"

            for i in range(len(multi_split)):
                multi_split[i] = multi_split[i].strip()
                multi_split[i] = multi_split[i].replace("~", "-")

            log += f"{multi_split}\n"
            while len(multi_split) != 1:
                one_value_list = multi_split[0].split(" ")
                two_value_list = multi_split[1].split(" ")

                try:
                    one_value_list.remove("")
                    two_value_list.remove("")
                except ValueError:
                    pass

                try:
                    one_value = int(one_value_list[-1])
                    two_value = int(two_value_list[0])
                except ValueError:
                    one_value = float(one_value_list[-1])
                    two_value = float(two_value_list[0])

                multi_value = one_value * two_value
                two_value_list.remove(two_value_list[0])

                one_value_list[-1] = multi_value.__str__()
                some_string = ""
                for each in one_value_list:
                    some_string += each + " "
                for each in two_value_list:
                    some_string += each + " "
                some_string = some_string.strip()

                log += f"{multi_split}\n"
                multi_split.remove(multi_split[0])
                multi_split.remove(multi_split[0])
                multi_split.insert(0, some_string)
            else:
                num = multi_split[0]

            # Addition ###############################
            add_split = num.split(" + ")
            log += f"+++{add_split}\n"

            for i in range(len(add_split)):
                add_split[i] = add_split[i].strip()
                add_split[i] = add_split[i].replace("~", "-")

            log += f"{add_split}\n"
            while len(add_split) != 1:
                one_value_list = add_split[0].split(" ")
                two_value_list = add_split[1].split(" ")

                try:
                    one_value_list.remove("")
                    two_value_list.remove("")
                except ValueError:
                    pass

                try:
                    one_value = int(one_value_list[-1])
                    two_value = int(two_value_list[0])
                except ValueError:
                    try:
                        one_value = float(one_value_list[-1])
                        two_value = float(two_value_list[0])
                    except ValueError:
                        exit(f"UCalc Excuses: Some non-calculable value (\"{num}\") has been given.")

                add_value = one_value + two_value
                two_value_list.remove(two_value_list[0])

                one_value_list[-1] = add_value.__str__()
                some_string = ""

                for each in one_value_list:
                    some_string += each + " "
                for each in two_value_list:
                    some_string += each + " "
                some_string = some_string.strip()

                log += f"{add_split}\n"
                add_split.remove(add_split[0])
                add_split.remove(add_split[0])
                add_split.insert(0, some_string)
            else:
                num = add_split[0]

            # Subtraction ##########################
            sub_split = num.split(" - ")
            log += f"---{sub_split}\n"

            for i in range(len(sub_split)):
                sub_split[i] = sub_split[i].replace("~", "-")
                sub_split[i] = sub_split[i].strip()

            log += f"{sub_split}\n"
            while len(sub_split) != 1:
                one_value_list = sub_split[0].split(" ")
                two_value_list = sub_split[1].split(" ")

                try:
                    one_value_list.remove("")
                    two_value_list.remove("")
                except ValueError:
                    pass
                log += f"{one_value_list}"
                log += f"{two_value_list}"
                log += f"{sub_split}"
                with open(path_to_log, "w") as file:
                    file.write(log)
                try:
                    one_value = int(one_value_list[-1])
                    two_value = int(two_value_list[0])
                except ValueError:
                    one_value = float(one_value_list[-1])
                    two_value = float(two_value_list[0])

                sub_value = one_value - two_value
                two_value_list.remove(two_value_list[0])

                one_value_list[-1] = sub_value.__str__()
                some_string = ""
                for each in one_value_list:
                    some_string += each + " "
                for each in two_value_list:
                    some_string += each + " "
                some_string = some_string.strip()

                log += f"{sub_split}\n"
                sub_split.remove(sub_split[0])
                sub_split.remove(sub_split[0])
                sub_split.insert(0, some_string)
            else:
                num = sub_split[0]

            return num


        def calculator_precedence(args):

            """ The calculator function of the program ignores the BODMAS rule
                but brackets are minded before
                calling this function to wrap expressions
                Example:
                5-2*2 or 5-2x2
                The above expression must yield the answer as 1.
                Without BODMAS, it will yield 6
                So, one can wrap the '2x2' inside brackets, thus the expression will be-
                5-[2*2] or 5-[2x2]
                hence, it will provide same answer as that of with BODMAS rule"""

            global log
            operator_list = ["+", "-", "/", "%", "^", "x", "*", "**"]
            numbers_list = []
            # Separating Arithmetic Operators From Numbers Block
            for each in range(len(args)):
                if "?" in args[each] or "!" in args[each]:
                    args[each] = factorial(args[each])
                    log += f"Factorial: {args}\n"
                elif args[each].startswith("_") or args[each].startswith("√"):
                    args[each] = square_root(args[each])
                    log += f"SquareRoot: {args}\n"
                elif args[each].startswith(":"):
                    args[each] = cube_root(args[each])
                    log += f"SquareRoot: {args}\n"

            with open(path_to_log, "w") as file:
                file.write(log)

            for each in args:
                log += f"{args} {numbers_list}\n"
                if each not in operator_list:
                    try:
                        each = int(each)
                    except ValueError:
                        try:
                            each = float(each)
                        except ValueError:
                            exit(f"""
UCalc Excuses: A non-calculable value({each})
has been given to me. Try --help for more information.""")
                    numbers_list.append(each)
                    args.remove(each.__str__())
                    log += f"OperaPrint: {args, numbers_list}\n"
            log += f"{args} {numbers_list}\n"
            log += f"Args 'n' nums{args, numbers_list}"

            # Calculation Block
            while True:
                log += f"CalcNumList: {numbers_list}, argsList: {args}\n"
                try:
                    if args[0] == "+":
                        value = numbers_list[0] + numbers_list[1]
                        numbers_list.remove(numbers_list[0])
                        numbers_list.remove(numbers_list[0])
                        numbers_list.insert(0, value)
                        args.remove(args[0])
                    elif args[0] == "-":
                        value = numbers_list[0] - numbers_list[1]
                        numbers_list.remove(numbers_list[0])
                        numbers_list.remove(numbers_list[0])
                        numbers_list.insert(0, value)
                        args.remove(args[0])
                    elif args[0] == "/":
                        value = numbers_list[0] / numbers_list[1]
                        numbers_list.remove(numbers_list[0])
                        numbers_list.remove(numbers_list[0])
                        numbers_list.insert(0, value)
                        args.remove(args[0])
                    elif args[0] == "%":
                        value = numbers_list[0] % numbers_list[1]
                        numbers_list.remove(numbers_list[0])
                        numbers_list.remove(numbers_list[0])
                        numbers_list.insert(0, value)
                        args.remove(args[0])
                    elif args[0] == "^" or args[0] == "**":
                        value = numbers_list[0] ** numbers_list[1]
                        numbers_list.remove(numbers_list[0])
                        numbers_list.remove(numbers_list[0])
                        numbers_list.insert(0, value)
                        args.remove(args[0])
                    elif args[0] == "x" or args[0] == "*":
                        value = numbers_list[0] * numbers_list[1]
                        numbers_list.remove(numbers_list[0])
                        numbers_list.remove(numbers_list[0])
                        numbers_list.insert(0, value)
                        args.remove(args[0])
                except IndexError:
                    break
            return numbers_list[0]


        # misc_list for creating spaces before and after for chars inside the list
        misc_list = ["+", "-", "/", "%", "^", "x", "*", "{", "}", "[", "]"]
        # First item from sys.argv is removed for it is the name of program
        try:
            sys.argv.remove(sys.argv[0])
            log += f"System-arguments = {sys.argv}\n"
        except IndexError:
            pass

        temporary_string = ""
        temporary_two_string = ""
        for each in sys.argv:
            temporary_string += each
            temporary_two_string += each
        log += f"temporary_two_string = {temporary_two_string}\n"
        # Removing optional commas from input
        temporary_string = temporary_string.replace(",", "").strip()
        log += f"Single: {temporary_string}\n"
        
        def interactive_input_receiver(temporary_string):
            global readline
            temporary_string = input("< ASK >: ").strip()
            splitted_temporary_string = temporary_string.split(" ")
            temporary_string = ""
            for each in splitted_temporary_string:
                temporary_string += each
            temporary_string.replace(",", "")
            for each in misc_list:
                temporary_string = temporary_string.replace(each, f" {each} ")
            
            if temporary_string == "help":
                print(i_help_view)
                main()
            elif temporary_string == "about":
                print(about_view)
                main()
            elif temporary_string == "version":
                print(version_view)
                main()
            elif temporary_string == "constants":
                print(constant_view)
                main()
            elif temporary_string == "quit":
                exit("< QUIT >")

            return temporary_string    

        # Checking for options from the user
        if temporary_string == "--help" or temporary_string == "-h":
            print(help_view)
            exit()
        elif temporary_string == "--about" or temporary_string == "-ab":
            print(about_view)
            exit()
        elif temporary_string == "--version" or temporary_string == "-v":
            print(version_view)
            exit()
        elif temporary_string == "--constants" or temporary_string == "-c":
            print(constant_view)
            exit()
        elif temporary_string == "-L":
            os.system(f"less {path_to_log}")
            exit()
        elif temporary_string == "-Lv":
            with open(path_to_log, "r") as file:
                print(file.read())
            exit()
        elif temporary_two_string == "-i" or temporary_two_string == "--interactive" or interactive:
            interactive = True
            temporary_string = interactive_input_receiver(temporary_string)
        
        # Checking extra inputs from the user

        # There will be a space between x and y because of
        # operator identification
        log += "### Passing on labour to XY factoriser ###\n"
        # In interactive the oprators are formatted before it is checked
        # for special inputs, thus, x y::
        called_xy_factoriser = False
        if "xy::" in temporary_string or "x y::" in temporary_string:
            if not os.path.exists("xy"):
                log += "### XY was not already compiled - first compilation ###\n"
                os.system(f"gcc {path_to_xy_c} -o {path_to_xy} -g -lgmp")
            temporary_string = temporary_string.replace("xy::", "")
            temporary_string = temporary_string.replace("x y::", "")
            find_xy_list = temporary_string.split("::")
            if len(find_xy_list) < 3:
                print("""
UCalc Excuses: There is insuffient arguments for finding the Product-Sum factor.
UCalc Exemplifies: xy::(Product)::(Sum)::(Counter Upto), xy::100::25::100
""")
                exit()
            if len(find_xy_list) > 3:
                print("UCalc Excuses: Redundant arguments while calling Product-Sum Factoriser.")
                exit()
            if interactive: 
                os.system(f"{path_to_xy} {find_xy_list[0]} {find_xy_list[1]} {find_xy_list[2]} 1")
            else:
                os.system(f"{path_to_xy} {find_xy_list[0]} {find_xy_list[1]} {find_xy_list[2]} 0")

            with open("ucalcLog.txt", "w") as file:
                file.write(log)
            called_xy_factoriser = True


        final_touch = ""
        precedence = False
        converter = "none"
        factorise = False
        if ".round" in temporary_string:
            temporary_string = temporary_string.replace(".round", "")
            final_touch = "round"
        elif ".ceil" in temporary_string:
            temporary_string = temporary_string.replace(".ceil", "")
            final_touch = "ceil"
        elif ".floor" in temporary_string:
            temporary_string = temporary_string.replace(".floor", "")
            final_touch = "floor"
        if ".precede" in temporary_string:
            temporary_string = temporary_string.replace(".precede", "")
            precedence = True

        types_of_converter = [".base64", ".hex", ".bin", ".oct", ".fromhex", ".frombin",
                              ".fromoct"]


        def extra_input_insurance(temporary_string):
            # Ensuring that there are no more than one converter call
            # Solely made with intention to integrate with converter calls
            for each in types_of_converter:
                temporary_string = temporary_string.replace(each, "")
            return temporary_string
        

            
        
        if ".base64" in temporary_string:
            temporary_string = temporary_string.replace(".base64", "")
            converter = "64"
        # In interactive mode, 'hex' becomes 'he x' due to
        # So, =>
        elif ".hex" in temporary_string or ".he x" in temporary_string:
            temporary_string = temporary_string.replace(".hex", "")
            temporary_string = temporary_string.replace(".he x", "")
            converter = "hex"
        elif ".bin" in temporary_string:
            temporary_string = temporary_string.replace(".bin", "")
            converter = "bin"
        elif ".oct" in temporary_string:
            temporary_string = temporary_string.replace(".oct", "")
            converter = "oct"
        elif ".ter" in temporary_string:
            temporary_string = temporary_string.replace(".ter", "")
            converter = "ter"
        elif ".from64" in temporary_string:
            temporary_string = temporary_string.replace(".from64", "")
            temporary_string = extra_input_insurance(temporary_string)
            try:
                prompt_reply = Converters().reverse_base64(temporary_string)
            except ValueError:
                exit("UCalc Excuses: You had either tried to do arithmetic operations or entered invalid base64 value.")
            log += "madeABaseSixtyFourPromptReply"
            log += ctime()
            with open(path_to_log, "w") as file:
                file.write(log)
            exit(f"UCalc has skipped everything and replied: {prompt_reply}")
        elif ".fromhex" in temporary_string or ".fromhe x" in temporary_string:
            temporary_string = temporary_string.replace(".fromhex", "")
            temporary_string = temporary_string.replace(".fromhe x", "")
            converter = "fromhex"
        elif ".frombin" in temporary_string:
            temporary_string = temporary_string.replace(".frombin", "")
            converter = "frombin"
        elif ".fromoct" in temporary_string:
            temporary_string = temporary_string.replace(".fromoct", "")
            converter = "fromoct"
        elif ".fromter" in temporary_string:
            temporary_string = temporary_string.replace(".fromter", "")
            converter = "fromter"
        
        if ".factor" in temporary_string or ".f" in temporary_string:
            factorise = True
            temporary_string = temporary_string.replace(".factor", "")
            temporary_string = temporary_string.replace(".f", "")
            if not os.path.exists(os.path.abspath("f")):
                log += "### First Factoriser Compilation ###"
                os.system(f"gcc {path_to_f_c} -o {path_to_f} -g -lgmp -w")
            log += "### Prepared labour for Factoriser ###\n"

        temporary_string = extra_input_insurance(temporary_string)

        along_with_answer = temporary_string

        for each in misc_list:
            temporary_string = temporary_string.replace(each, f" {each} ")
            temporary_string = temporary_string.replace("  ", " ")

        log += f"{temporary_string}\n"
        yet_another_list = temporary_string.split(" ")

        temp_string = ""
        for each in yet_another_list:
            temp_string += each + " "
            temp_string = temp_string.replace("]", "|@")
            temp_string = temp_string.replace("[", "|@#")
            """
            In the above line of code, the ] is constituted with |@
            but [ is constituted with |@# because after getting split with
            '|', it again, is grouped into a list after calculating the inner brackets
            or { and }, to receive a correct differentiation after splitting, both are given
            '@' but to recognise whether the item from list was in a bracket # has been
            utilised.
            """
            temp_string = temp_string.replace("{", "|&")
            temp_string = temp_string.replace("}", "|")

            # Special Values
            temp_string = temp_string.replace("pi", (22 / 7).__str__())  # Pi
            temp_string = temp_string.replace("π", (22 / 7).__str__())  # Pi
            temp_string = temp_string.replace("g", "9.8")  # Gravity of the Earth
            temp_string = temp_string.replace("G", (6.673 * 10 ** -11).__str__())  # Universal Gravitational Constant
            temp_string = temp_string.replace("R", "8.314")  # Universal Gas Constant
            temp_string = temp_string.replace("h", (6.62 * 10 ** -34).__str__())  # Planck's Constant
            temp_string = temp_string.replace("N", (6.022 * 10 ** 23).__str__()) # Avogadro's Number
            temp_string = temp_string.replace("k", (1.38 * 10 ** -23).__str__()) # Boltzmann Constant
            temp_string = temp_string.replace("F", (9.649 * 10 ** 4).__str__()) # Faraday Constant
            temp_string = temp_string.replace("C", (2.9979 * 10 ** 8).__str__()) # Speed Of Light In Vacuum

            # Negative Value Argument Receiver
            temp_string = temp_string.replace("~", "-")

        args = temp_string.split("|")
        for each in args:
            each = each.strip()
        log += f"{args}\n"

        result_list = []
        string = ""

        # Curly Brackets #####################
        for each in args:
            each = each.strip()
            log += f"{each}\n"
            if "&" in each:
                crlybrkts = "{}"
                log += f"True{crlybrkts}: {each}\n"
                if not precedence:
                    returned_value = calculator_bodmas(each.replace("&", "").strip())
                else:
                    returned_value = calculator_precedence(each.replace("&", "").strip().split(" "))
                returned_value = returned_value.replace("- ", "")
                log += f"Returned: {returned_value}\n"
                result_list.append(returned_value)
            else:
                result_list.append(each)

        with open(path_to_log, "w") as file:
            file.write(log)

        log += f"{args}\n"
        try:
            result_list.remove("@")
        except ValueError:
            pass
        log += f"{result_list}\n"

        for each in result_list:
            string += (each.__str__() + "$")
        string = string.strip()
        #
        string = string.replace(" - ", "substitute_text")
        string = string.replace("substitute_text", " - ")
        string = string.replace("--", "+")
        log += f"After Skirmish: {string}\n"

        result_list = []

        # Here result_string_list gets split with @
        result_string_list = string.split("@")
        log += f"ResultStringList: {result_string_list}\n"

        for i in range(len(result_string_list)):
            result_string_list[i] = result_string_list[i].replace("$$", "$")
            result_string_list[i] = result_string_list[i].replace("$", " ")
            result_string_list[i] = safety_formatting(result_string_list[i])

        # Square Brackets #####################
        for each in result_string_list:
            each = each.strip()
            if "#" in each:
                log += f"True[]: {each}\n"
                if not precedence:
                    returned_value = calculator_bodmas(each.replace("#", "").strip())
                else:
                    returned_value = calculator_precedence(each.replace("#", "").strip().split(" "))

                log += f"Returned: {returned_value}\n"
                result_list.append(returned_value)
            else:
                result_list.append(each)

        log += f"Before Replacement{result_list}\n"
        string = ""
        for each in result_list:
            string += (each.__str__() + " ")
        string = safety_formatting(string)
        log += f"After Replacement: {string}\n"

        with open(path_to_log, "w") as file:
            file.write(log)

        # Implementing extra input from the user
        if not precedence:
            reply = calculator_bodmas(string)
        else:
            reply = calculator_precedence(string.split(" "))

        if final_touch == "round":
            reply = round(float(reply))
            log += "roundHasBeenCalled;fromPriorityOne\n"
        elif final_touch == "ceil":
            reply = math.ceil(float(reply))
            log += "ceilHasBeenCalled;fromPriorityTwo\n"
        elif final_touch == "floor":
            reply = math.floor(float(reply))
            log += "floorHasBeenCalled;fromPriorityThree\n"
        else:
            log += "noSpecialInputUsed;fromNull\n"

        conversion = Converters()
        if converter == "64":
            reply = conversion.base64(reply.__str__())
            log += "hasCalledUponBaseSixtyFourConverter\n"
        elif converter == "hex":
            reply = conversion.hexadecimal(reply.__str__())
            log += "hasCalledUponHexDecimalConverter\n"
        elif converter == "oct":
            reply = conversion.octal(reply.__str__())
            log += "hasCalledUponOctalConverter\n"
        elif converter == "ter":
            reply = conversion.ternary(reply.__str__())
            log += "hasCalledUponTernaryConverter\n"
        elif converter == "bin":
            reply = conversion.binary(reply.__str__())
            log += "hasCalledUponBinaryConverter\n"
        elif converter == "fromhex":
            reply = conversion.reverse_hexadecimal(reply.upper())
            log += "hasCalledUponReverseHexDecimalConverter\n"
        elif converter == "frombin":
            reply = conversion.reverse_binary(reply)
            log += "hasCalledUponReverseBinaryConverter\n"
        elif converter == "fromter":
            reply = conversion.reverse_ternary(reply)
            log += "hasCalledUponReverseBinaryConverter\n"
        elif converter == "fromoct":
            reply = conversion.reverse_octal(reply)
            log += "hasCalledUponReverseOctalConverter\n"
        else:
            log += "proceedingWithDefaultBase\n"
        

        if interactive:
            if factorise:
                os.system(f"{path_to_f} {reply} 1")
            else:
                if not called_xy_factoriser:
                    print(f"< REPLY >: {reply}")
                    log += f"UCalc Replied: {along_with_answer} = {reply} @ {ctime()}\n"
                ending_time = time()
                total_time = ending_time - starting_time
                log += f"[END] in {total_time}"
            with open(path_to_log, "w") as file:
                file.write(log)
            main()

        else:
            if factorise:
                os.system(f"{path_to_f} {reply} 0")
            else:
                if not called_xy_factoriser:
                    print(f"UCalc Replies: {reply}")
                    log += f"UCalc Replied: {along_with_answer} = {reply} @ {ctime()}\n"
                ending_time = time()
                total_time = ending_time - starting_time
                log += f"[END] in {total_time}"
                log += f"UCalc was liberated @ {ctime()} only employed for {total_time}"
        with open(path_to_log, "w") as file:
            file.write(log)

    except KeyboardInterrupt:
        ending_time = time()
        total_time = ending_time - starting_time
        log += f"UCalc was liberated @ {ctime()} only employed for {total_time}"
        with open(path_to_log, "w") as file:
            file.write(log)
        exit("-- UCalc has been liberated --")
main()

