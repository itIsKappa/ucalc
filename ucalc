#! /usr/bin/python3

# UCalc © 2020 Hathim Ali
# Distributed under GNU GPL v3

# If you are running this program from the folder itself
# rather moving it into /usr/bin or running it after 
# installing it using the deb package or install.sh,
# it is strongly adviced that you may run it
# not by 'python3 ucalc' but './ucalc'

interactive = False

def main():
    try:
        import sys
        import os
        from time import ctime
        from time import time
        import math
        import readline

        starting_time = time()
        global interactive
        global log
        global log_file

        path_to_log = "ucalcLog.txt" 
        path_to_f = "./f"
        path_to_f_c = "f.c"
        path_to_xy = "./xy"
        path_to_xy_c = "xy.c"
        path_to_pf_c = "p.c"
        path_to_pf = "./p"
        path_to_ans = "ans"
        version = "v4.5.9"

        log_file = open(path_to_log, "w")
        if not interactive:
            log_file.write(f"{ctime()}\n")
        else:
            log_file.write(f"{ctime()}\n")
        
        try:
            with open(path_to_ans, "r") as file:
                ans = file.read()
        except FileNotFoundError:
            open(path_to_ans, "w").write("1")
            with open(path_to_ans, "r") as file:
                ans = file.read()

        version_view = f"""
UCalc © 2020 HathimAli
Stable Version
UCalc {version}
     """

        about_view = """
======================= 
     A  B  O  U  T        
=======================
UCalc © 2020 HathimAli
UCalc is distributed under GNU General Public License v3.
See the GNU GPL documentation provided with this program
or reach the web.
UCalc is a command-line-interface calculator supplied with rich features.
Any means of crashing, hopes to be reported by the user.
Users can mail to the address -- honeyt2019@gmail.com
It is a best practice to include the ucalcLog.txt to be
found at /usr/share/ucalc 
========================
"""
        help_view = f"""
Usage:
ucalc [expression]
ucalc [option]

=====================
E X P R E S S I O N S
=====================
-----------------------
   O P E R A T O R S
-----------------------
UCalc supports all arithmetic operators:
+ for addition
- for subtraction
x or * or · for multiplication
/ for division but returns quotient
% for division but returns remainder
^ for raising to the power
-------------------------
UCalc has made arithmetic operators intuitive.
Usage of x rather than * for multiplication is encouraged.
* may have to be preceded by \\ to escape * as it is a special character.
So, it is faster and less to write 8x4 rather than 8\\*4.

-------------------------
     B R A C K E T S       
-------------------------
UCalc also supports brackets. It can understand three types of brackets
commonly found on almost every keyboard and configuration, which are
'()', '[]', '{"{}"}'.
Deep nesting of brackets is also possible indiscriminate of which type
used. If there are incomplete brackets detected, UCalc will call off 
the calculations and alarm you.

---------------------------------------------------------------------------
   F A C T O R I A L S,  S Q U A R E R O O T S  A N D  C U B E R O O T S
---------------------------------------------------------------------------
Factorials:
    There are two ways to tell UCalc to find a number's factorial.
    First is to add "!" to ending of a number.
    Though, you may have to add a backslash before the exclamation mark
    as it is a special character.
    Another, will be to add "?" to ending of a number as it avoids
    having to enter a backslash everytime before you type an
    exclamation mark.
    Exempli gratia, 5\\! will return 120, but, 5? also returns 120 and it is
    lesser to write.
    Again, [3\\!]\\! will return 720, but, there is backslashes two
    times and your inputs becomes less readable and understandable to
    [3?]?, wherein one can quickly read and understand the expression,
    in both, UCalc can read your input and return an answer.

Square-roots:
    Akin to factorial, there are two ways for you when you want get the
    square root of a number. Reason for being provided with two ways
    is similar to factorial.
    First is to use the actual square root symbol or "√".
    It is not available in every in keyboard layout and thus calls
    for a better and easier way.
    The better way is to, use an underscore or "_".
    Exempli gratia, _25 will return 5
               _[64+46] will return 10
               If you try finding square root of a number that is
               not a square, you will a decimal number upto 15 digits,
               like,
               _2 for which UCalc will return 1.4142135623730951

Cube-roots:
    Fortunately and unfortunately, there is only way in which you can
    find the cube root of a number and that is to add a colon or ":"
    to the beginning like you have done as in above cases.
    Exempli gratia, :27 will give 3

---------------------
    F A C T O R S      
---------------------
UCalc also provides for fetching factors of a given number.
Similar to the many extra inputs, which happens to be mentioned
below extra inputs section, the number is to end with either
'.factor' or '.f'
Exempli gratia, 4.factor wil return 1, 2, 4
We can also do arithmetics before finding the factors,
2+2.factor will also return 1, 2, 4

-------------------
    P R I M E S
-------------------
UCalc also has a functionality that can fetch all the prime
numbers upto the specified value. This is also called
with a period '.' and the word 'primes' followed and this
also falls under the extra inputs section. The period can also
be followed by a 'p'.
Exempli gratia, 5.primes will return 2, 3, 5
Whatever applies to FACTORS also takes this in consideration.

---------------------------------------------
    P R O D U C T - S U M   F A C T O R S   
---------------------------------------------
UCalc is shipped with XY, a product-sum factor finder.
Since, XY requires, at the least, three inputs, which they
are will be told further down, the method of calling used is
known as the Double-Colon-Call. First, you have to enter
the type of Double-Colon function you are calling, here,
it is the product-sum factor finder, which has, undoubtedly,
the name 'xy'. XY requires three arguments and no more.
They are, with respect to order, the product, the sum and
the counter. The product and the sum are obvious but the counter
may not be. The counter determines upto how much to count to,
beginning from one.
Exempli gratia,
xy::100::25::100 will return 20 and 5.
Since, the larget among the result is 20, all the numbers
thence was unnecassary even though the XY will stop when
it finds a factor. Now here,
xy::100::25::10, will not return a factor since it is 
larger than the counter specified.
Above, we have called XY and immediately entered
double-colons and every argument has to be separated by
double colons, hence, the name Double-Colon-Call.

=====================================
R U L E S  O F  C A L C U L A T I O N
=====================================
UCalc, by default and implicitly, uses the rule of BODMAS.
It can also use the rule of precedence though it has to be explicitly
mentioned as it falls under the category of extra inputs.
Thus, an expression followed by '.precede' will prompt UCalc to use
the rule of precedence.
Exempli gratia, 5-4x2 will return -3, but,
5-4x2.precede will return 2

============================
N E G A T I V E  V A L U E S
============================
Negating a value in UCalc is simple.
You should add ~ to the beginning of the number.
Exempli gratia, 2--2 or 2-[-2] is wrong and it will cause errors.
           2-~2 is the right way and will return the aniticipated value,
           id est, 0
Simply a minus sign is considered an arithmetic operator to UCalc,
if only a value begins with ~, UCalc will consider it negative.

======================
E X T R A  I N P U T S
======================
Some extra inputs have been predefined for UCalc which affects the result
of the calculation. All extra inputs are akin to how you have to mention
to UCalc to use the rule of precedence rather than BODMAS (If you have
not read about it, it is aforementioned under the section--
"RULES OF CALCULATION"), all extra inputs begin with a period or ".".
The extra inputs are as follows:
    round - estimately rounds the result, if it is a floating point
            number.
            Exempli gratia, 5/2 will return 2.5, but,
            5/2.round will return simply 2
    
    ceil - rounds the result but to the nearest highest value to
           the result ('ceiling' is shortened to 'ceil').
           Exempli gratia, 5/2.round will return 2 , but,
           5/2.ceil will return 3.

    floor - rounds the result but to the nearest lowest value to 
            the result ('floor' is contrary to 'ceil'/'ceiling').
            Exempli gratia, 5/3 will return 1.6666666666666667, but,
            5/3.floor will return 1 on the other hand, if you are
            to use '.round', then, the answer will be 2 for the
            result is evidently above 1.5, so, as the estimation will
            be to round to the nearest value the result is such,
            id est, 2.

===================
C O N V E R T E R S
===================
UCalc also has some built-in base converters. Like extra inputs,
the converters will convert the final value and display it to you.
And also, again like extra inputs, these also have to be preceded with
period or '.'.
The converters are as follows:

    bin - converts the result to binary/base-2.

    ter - converts the result to ternanray/base-3.

    oct - converts the result to octal/base-8.

    hex - converts the result to hexadecimal/base-16.

    base64 - converts the result to base64.

Base-64 converter has to be used with caution as it is custom made for
UCalc and value representation may differ heavily with other converters
and thus, it may no be reverse convertible with other converters, though,
UCalc also has built-in reverse converters for all of the above converters.
Converter will accept floating point values or a number that contains Euler's.
The best way to such is to use round, ceil or floor extra input with the
converters.

----------------------------------------
   R E V E R S E  C O N V E R T E R S
----------------------------------------
Everything is as above except the names to invoke these converters differ.
The reverse converters are as follows:

    frombin - converts the given value from binary to decimal.

    fromter - converts the given from ternary to decimal.

    fromoct - converts the given value from octal to decimal.

    fromhex - converts the given value from hexadecimal to decimal.

    from64 - converts the given the value from base-64 to decimal.

It is upon you that you should not include other than 1 or 0 in
reverse binary converter, nothing but between 0 - 7 in
octal converter and between 0 - 3 in ternary converter
for even if you are to enter wrong values to
binary, octal and ternary converters, they will tolerate
and return a wrong value. Where as hexadecimal and base-64 reverse
converters will not tolerate and excuse that they have been given a
non-convertible value. 
 
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

========================
     O P T I O N S
========================

--help or -h - brings about what you are seeing.

--about or -ab - brings about more information about licensing
                 and the program.

--version or -v - brings about information about the version of the
                  program that you are currently running.

--constants or -c - brings about the list containing constants supported
                    by UCalc {version}

-L - shows the log of last calculation using "less" utility in Linux.

-Lv - dumps the log of last calculation into terminal or standard out.

========================
||||||||||||||||||||||||| UCalc © 2020 HathimAli |||||||||||||||||||||||||
"""
        constant_view = f""" 
===================
 C O N S T A N T S
===================
UCalc is packed with a few constants which avails you from typing 
specific values everytime and makes UCalc less verbose.
Exempli gratia, rather than entering 2x22/7x7,
           you can enter 2xpix7 and it returns 44 

Constants supported by UCalc {version} are as follows:

    pi - it stands for Pi, can also use the greek letter "π" for Pi
    g - it stands for Earth's gravity
    G - it stands for the Universal Gravitational Constant
    R - it stands for the Gas Constant
    h - it stands for Planck's Constant
    N - it stands for Avogadro's Number
    C - it stands for Speed of Light in Vacuum
    F - it stands for Faraday Constant
    k - it stands for Boltzmann Constant

====================
    """
        simple_constant_view = """
<>-------------------------------------------<>
    pi : Pi, also (π)
    g : Earth's gravity
    G : Universal Gravitational Constant
    R : Gas Constant
    h : Planck's Constant
    N : Avogadro's Number
    c : Speed of Light in Vacuum
    F : Faraday Constant
    k : Boltzmann Constant
<>-------------------------------------------<>
"""
        i_help_view = f"""
=======================================
I N T E R A C T I V E  M O D E  H E L P
=======================================
Rules and functionality are same as simply evoking UCalc.
There are some special input for using interactive mode
and they are as follows:
    
    quit - quit interactive mode
    about - brings about more information about UCalc
    version - brings about the current version you are running
    help - brings about a helpful guide on how to use UCalc
    constants - brings about the list containing all constants
                supported by UCalc {version}
---------------------------------------
Since you are not in a terminal, special characters like
"!" and "*" will not be a issue.

¡NOTE!: Options do not require hyphens in interactive mode.
---------------------------------------
        """

        class Converters():

            def error_correction(self, number):
                number = str(number)
                if "." in number or "e" in number:
                    if interactive:
                        print("UCalc Excuses: Cannot convert numbers with floating value or Euler's.")
                        main()
                    else: exit("UCalc Excuses: Cannot convert numbers with floating value or Euler's.")

            def reverse_ternary(self, num):
                def middle(num):
                    value = 0
                    items = []
                    for each in num:
                        items.append(each)
                    items.reverse()
                    nos = len(items)
                    for each in range(nos):
                        items[each] = int(items[each])
                    for each in range(nos):
                        value += 3 ** each * items[each]
                    return value

                num = num.split(" ")
                toAppend = ""
                for each in num:
                    each = middle(each)
                    each = str(each)
                    toAppend += each + " "
                return toAppend

            def reverse_hexadecimal(self, num):
                hex_alpha_values = {
                    "A": 10,
                    "B": 11,
                    "C": 12,
                    "D": 13,
                    "E": 14,
                    "F": 15,
                }

                def middle(num):
                    value = 0
                    items = []
                    for each in num:
                        items.append(each)
                    items.reverse()
                    nos = len(items)
                    for each in range(nos):
                        each = int(each)
                        each_value = hex_alpha_values.get(items[each], items[each])
                        try:
                            each_value = int(each_value)
                        except ValueError:
                            if interactive:
                                print("UCalc Excuses: Input does not appear to be hexadecimal value.")
                                main()
                            else: exit("UCalc Excuses: Input does not appear to be hexadecimal value.")
                        value += 16 ** each * each_value
                    return value

                num = num.split(" ")
                to_append = ""
                for each in num:
                    each = middle(each)
                    each = str(each)
                    to_append += each + " "
                return to_append

            def reverse_binary(self, num):
                def middle(num):
                    value = 0
                    items = []
                    for each in num:
                        items.append(each)
                    items.reverse()
                    nos = len(items)
                    for each in range(nos):
                        items[each] = int(items[each])
                    for each in range(nos):
                        value += 2 ** each * items[each]
                    return value

                num = num.split(" ")
                to_append = ""
                for each in num:
                    each = middle(each)
                    each = str(each)
                    to_append += each + " "
                return to_append.strip()

            def reverse_octal(self, num):
                def middle(num):
                    value = 0
                    items = []
                    for each in num:
                        items.append(each)
                    items.reverse()
                    nos = len(items)
                    for each in range(nos):
                        items[each] = int(items[each])
                    for each in range(nos):
                        value += 8 ** each * items[each]
                    return value

                num = num.split(" ")
                to_append = ""
                for each in num:
                    each = middle(each)
                    each = str(each)
                    to_append += each + " "
                return to_append

            def reverse_base64(self, num):
                hex_alpha_values = {
                     "A": 10,
                     "B": 11,
                     "C": 12,
                     "D": 13,
                     "E": 14,
                     "F": 15,
                     "G": 16,
                     'H': 17,
                     "I": 18,
                     "J": 19,
                     "K": 20,
                     "L": 21,
                     "M": 22,
                     "N": 23,
                     "O": 24,
                     "P": 25,
                     "Q": 26,
                     "R": 27,
                     "S": 28,
                     "T": 29,
                     "U": 30,
                     "V": 31,
                     "W": 32,
                     "X": 33,
                     "Y": 34,
                     "Z": 35,
                     "a": 36,
                     "b": 37,
                     "c": 38,
                     "d": 39,
                     "e": 40,
                     "f": 41,
                     "g": 42,
                     "h": 43,
                     "i": 44,
                     "j": 45,
                     "k": 46,
                     "l": 47,
                     "m": 48,
                     "n": 49,
                     "o": 50,
                     "p": 51,
                     "q": 52,
                     "r": 53,
                     "s": 54,
                     "t": 55,
                     "u": 56,
                     "v": 57,
                     "w": 58,
                     "x": 59,
                     "y": 60,
                     "z": 61,
                     "-": 62,
                     "_": 63,
                }
                def middle(num):
                    value = 0
                    items = []
                    for each in num:
                        items.append(each)
                    items.reverse()
                    nos = len(items)
                    for each in range(nos):
                        each = int(each)
                        each_value = hex_alpha_values.get(items[each], items[each])
                        each_value = int(each_value)
                        value += 64 ** each * each_value
                    return value

                num = num.split(" ")
                to_append = ""
                for each in num:
                    each = middle(each)
                    each = str(each)
                    to_append += each + " "
                return to_append

            def ternary(self, number):
                Converters().error_correction(number)
                number = number.split(" ")
                valum_final = ''
                for num in number:
                    item = []
                    try:
                        num = int(num)
                    except ValueError:
                        break
                    while True:
                        valum_finale = ''
                        value = num // 3
                        value2 = num % 3
                        item.append(value2)
                        num = value
                        if num == 0:
                            item.reverse()
                            for each in item:
                                valum_finale += each.__str__()
                            valum_final += valum_finale + " "
                            break
                        else:
                            pass
                return valum_final

            def hexadecimal(self, number):
                Converters().error_correction(number)
                hex_strings = {
                    10: "A",
                    11: "B",
                    12: "C",
                    13: "D",
                    14: "E",
                    15: "F",
                }
                number = number.replace("-", "")
                number = number.split(" ")
                valum_final = ''
                for num in number:
                    item = []
                    try:
                        num = int(num)
                    except ValueError:
                        break
                    while True:
                        valum_finale = ''
                        value = num // 16
                        value2 = num % 16
                        value2 = hex_strings.get(value2, value2)
                        item.append(value2)
                        num = value
                        if num == 0:
                            item.reverse()
                            for each in item:
                                valum_finale += each.__str__()
                            valum_final += valum_finale + " "
                            break
                        else:
                            pass
                return valum_final

            def binary(self, number):
                Converters().error_correction(number)
                number = number.replace("-", "")
                number = number.split(" ")
                valum_final = ''
                for num in number:
                    item = []
                    try:
                        num = int(num)
                    except ValueError:
                        break
                    while True:
                        valum_finale = ''
                        value = num // 2
                        value2 = num % 2
                        item.append(value2)
                        num = value
                        if num == 0:
                            item.reverse()
                            for each in item:
                                valum_finale += each.__str__()
                            valum_final += valum_finale + " "
                            break
                        else:
                            pass
                return valum_final

            def octal(self, number):
                Converters().error_correction(number)
                number = number.replace("-", "")
                number = number.split(" ")
                valum_final = ''
                for num in number:
                    item = []
                    try:
                        num = int(num)
                    except ValueError:
                        break
                    while True:
                        valum_finale = ''
                        value = num // 8
                        value2 = num % 8
                        item.append(value2)
                        num = value
                        if num == 0:
                            item.reverse()
                            for each in item:
                                valum_finale += each.__str__()
                            valum_final += valum_finale + " "
                            break
                        else:
                            pass
                return valum_final

            def base64(self, number):
                Converters().error_correction(number)
                base_sixty_four_strings = {
                    10: "A",
                    11: "B",
                    12: "C",
                    13: "D",
                    14: "E",
                    15: "F",
                    16: "G",
                    17: 'H',
                    18: "I",
                    19: "J",
                    20: "K",
                    21: "L",
                    22: "M",
                    23: "N",
                    24: "O",
                    25: "P",
                    26: "Q",
                    27: "R",
                    28: "S",
                    29: "T",
                    30: "U",
                    31: "V",
                    32: "W",
                    33: "X",
                    34: "Y",
                    35: "Z",
                    36: "a",
                    37: "b",
                    38: "c",
                    39: "d",
                    40: "e",
                    41: "f",
                    42: "g",
                    43: "h",
                    44: "i",
                    45: "j",
                    46: "k",
                    47: "l",
                    48: "m",
                    49: "n",
                    50: "o",
                    51: "p",
                    52: "q",
                    53: "r",
                    54: "s",
                    55: "t",
                    56: "u",
                    57: "v",
                    58: "w",
                    59: "x",
                    60: "y",
                    61: "z",
                    62: "-",
                    63: "_",
                }
                number = number.replace("-", "")
                number = number.split(" ")
                valum_final = ''
                for num in number:
                    item = []
                    try:
                        num = int(num)
                    except ValueError:
                        break
                    while True:
                        valum_finale = ''
                        value = num // 64
                        value2 = num % 64
                        value2 = base_sixty_four_strings.get(value2, value2)
                        item.append(value2)
                        num = value
                        if num == 0:
                            item.reverse()
                            for each in item:
                                valum_finale += each.__str__()
                            valum_final += valum_finale + " "
                            break
                        else:
                            pass
                if interactive:
                    print("< !! >: This base sixty four conversion may not be reverse convertible in other programs."
                          "\n*** same conversion values used by YouTube's video identities  ***")
                else: print("UCalc Warns: This base sixty four conversion may not be reverse convertible in other programs."
                            "\n*** same conversion values used by YouTube's video identities  ***")
                return valum_final


        def safety_formatting(string):
            string = string.strip()
            string = string.replace("~ ", "~")
            string = string.replace("_ ", "_")
            string = string.replace(" _ ", "_")
            string = string.replace(" - ", "substitute_text")
            string = string.replace("- ", "-")
            string = string.replace("substitute_text", " - ")
            string = string.replace("--", "+")
            string = string.replace("~~", "+")
            string = string.replace("++", "+")
            string = string.replace(" ?", "?")
            string = string.replace(" !", "!")
            return string
        
            
        def cube_root(num):
            global log, log_file
            log_file.write(log)
            num = num.replace(":", "")
            try: num = int(num)
            except ValueError:
                if interactive:
                    print(f"< ! >: Some non-calculable value('{num}') has been given to me.")
                    main()
                else: exit(f"UCalc Excuses: Some non-calculable value('{num}') has been given to me.")
            value = math.ceil(num ** 0.333333333333333)
            return value.__str__()

        def factorial(num):
            global log, log_file
            """ The original factorial finder has been
                made common to act as a fallback """
            log_file.write(f"{num}")
            log_file.write(log)
            num = num.replace("?", "")
            num = num.replace("!", "")
            try:
                num = int(num)
            except ValueError:
                try:
                    num = float(num)
                except ValueError:
                    if interactive:
                        print(f"< ! >: Some non-calculable value('{num}') has been given to me.")
                        main()
                    else: exit(f"UCalc Excuses: Some non-calculable value('{num}') has been given to me.")

            # Fallback # factorial_list = [1]
            # Fallback # factorial_value = 1
            # Fallback # while num != 0:
            # Fallback #     factorial_list.append(num)
            # Fallback #     num = num - 1
            # Fallback # for each in factorial_list:
            # Fallback #     factorial_value *= each
            # Fallback # return factorial_value.__str__()

            try:
                return math.factorial(num).__str__()
            except ValueError:
                if interactive:
                    print(f"""
< ! >: Some expression in your input resulted in a floating point value and that value called to find its factorial.
            Finding factorial of floating point values is impossible;
            Your resultant number before calling for finding factorial is {num}  
""")
                    main()
                else: exit(f"""
UCalc Excuses: Some expression in your input resulted in a floating point value and that value called to find its factorial.
               Finding factorial of floating point values is impossible;
               Your resultant number before calling for finding factorial is {num}  
""")

        def square_root(num):
            num = num.replace("_", "")
            num = num.replace("√", "")
            try:
                num = int(num)
            except ValueError:
                try:
                    num = float(num)
                except ValueError:
                    if interactive:
                        print(f"< ! >: Cannot find square-roots of non-numerical value; ('{num}')")
                        main()
                    else: exit(f"UCalc Excuses: Cannot find square-roots of non-numerical value; ('{num}')")
            return math.sqrt(num).__str__()

        def calculator_bodmas(num):
            global log, log_file
            some_list = num.split(" ")
            to_be_num_string = ""
            for each in range(len(some_list)):
                if "?" in some_list[each] or "!" in some_list[each]:
                    some_list[each] = factorial(some_list[each])
                    log_file.write(f"Factorial: {some_list[each]}\n")
                elif some_list[each].startswith("_") or some_list[each].startswith("√"):
                    some_list[each] = square_root(some_list[each])
                    log_file.write(f"SquareRoot: √{some_list[each]}\n")
                elif some_list[each].startswith(":"):
                    some_list[each] = cube_root(some_list[each])
                    log_file.write(f"CubeRoot: {some_list[each]}\n")
            for each in some_list:
                to_be_num_string += each + " "
            to_be_num_string = to_be_num_string.strip()
            log_file.write(f"to_be_num: {to_be_num_string}\n")
            num = to_be_num_string

            # RaiseTo / PowerOf #############################
            pow_split = num.split(" ^ ")
            log_file.write(f"^^^{pow_split}\n")
            for i in range(len(pow_split)):
                pow_split[i] = pow_split[i].strip()
                pow_split[i] = pow_split[i].replace("~", "-")

            log_file.write(f"{pow_split}\n")
            while len(pow_split) != 1:
                one_value_list = pow_split[0].split(" ")
                two_value_list = pow_split[1].split(" ")

                try:
                    one_value_list.remove("")
                    two_value_list.remove("")
                except ValueError:
                    pass

                try:
                    one_value = int(one_value_list[-1])
                    two_value = int(two_value_list[0])
                except ValueError:
                    one_value = float(one_value_list[-1])
                    two_value = float(two_value_list[0])

                pow_value = one_value ** two_value
                two_value_list.remove(two_value_list[0])

                one_value_list[-1] = pow_value.__str__()
                some_string = ""
                for each in one_value_list:
                    some_string += each + " "
                for each in two_value_list:
                    some_string += each + " "
                some_string = some_string.strip()

                log_file.write(f"{pow_split}\n")
                pow_split.remove(pow_split[0])
                pow_split.remove(pow_split[0])
                pow_split.insert(0, some_string)
            else:
                num = pow_split[0]

            # Division ################################
            div_split = num.split(" / ")
            log_file.write(f"///{div_split}\n")

            for i in range(len(div_split)):
                div_split[i] = div_split[i].strip()
                div_split[i] = div_split[i].replace("~", "-")

            log_file.write(f"{div_split}\n")
            while len(div_split) != 1:
                one_value_list = div_split[0].split(" ")
                two_value_list = div_split[1].split(" ")

                try:
                    one_value_list.remove("")
                    two_value_list.remove("")
                except ValueError:
                    pass

                try:
                    one_value = int(one_value_list[-1])
                    two_value = int(two_value_list[0])
                except ValueError:
                    one_value = float(one_value_list[-1])
                    two_value = float(two_value_list[0])
                try:
                    div_value = one_value / two_value
                except ZeroDivisionError:
                    if interactive:
                        print("< ! >: Cannot divide by zero ¯\\_('- ')_/¯")
                        main()
                    else: exit("UCalc Excuses: Cannot divide by zero ¯\\_('- ')_/¯")

                two_value_list.remove(two_value_list[0])

                one_value_list[-1] = div_value.__str__()
                some_string = ""
                for each in one_value_list:
                    some_string += each + " "
                for each in two_value_list:
                    some_string += each + " "
                some_string = some_string.strip()

                log_file.write(f"{div_split}\n")
                div_split.remove(div_split[0])
                div_split.remove(div_split[0])
                div_split.insert(0, some_string)
            else:
                num = div_split[0]

            # Remainder / Modulus ############################
            modulus_split = num.split(" % ")
            log_file.write(f"%%%{modulus_split}\n")
            log_file.write(f"")
            for i in range(len(modulus_split)):
                modulus_split[i] = modulus_split[i].strip()
                modulus_split[i] = modulus_split[i].replace("~", "-")

            log_file.write(f"{modulus_split}\n")
            while len(modulus_split) != 1:
                one_value_list = modulus_split[0].split(" ")
                two_value_list = modulus_split[1].split(" ")

                try:
                    one_value_list.remove("")
                    two_value_list.remove("")
                except ValueError:
                    pass

                try:
                    one_value = int(one_value_list[-1])
                    two_value = int(two_value_list[0])
                except ValueError:
                    one_value = float(one_value_list[-1])
                    two_value = float(two_value_list[0])

                modulus_value = one_value % two_value
                two_value_list.remove(two_value_list[0])

                one_value_list[-1] = modulus_value.__str__()
                some_string = ""
                for each in one_value_list:
                    some_string += each + " "
                for each in two_value_list:
                    some_string += each + " "
                some_string = some_string.strip()

                log_file.write(f"{modulus_split}\n")
                modulus_split.remove(modulus_split[0])
                modulus_split.remove(modulus_split[0])
                modulus_split.insert(0, some_string)
            else:
                num = modulus_split[0]

            # Multiplication ###############################
            multi_split = num.split(" x ")
            log_file.write(f"***{multi_split}\n")

            for i in range(len(multi_split)):
                multi_split[i] = multi_split[i].strip()
                multi_split[i] = multi_split[i].replace("~", "-")

            log_file.write(f"{multi_split}\n")
            while len(multi_split) != 1:
                one_value_list = multi_split[0].split(" ")
                two_value_list = multi_split[1].split(" ")

                try:
                    one_value_list.remove("")
                    two_value_list.remove("")
                except ValueError:
                    pass

                try:
                    one_value = int(one_value_list[-1])
                    two_value = int(two_value_list[0])
                except ValueError:
                    one_value = float(one_value_list[-1])
                    two_value = float(two_value_list[0])

                multi_value = one_value * two_value
                two_value_list.remove(two_value_list[0])

                one_value_list[-1] = multi_value.__str__()
                some_string = ""
                for each in one_value_list:
                    some_string += each + " "
                for each in two_value_list:
                    some_string += each + " "
                some_string = some_string.strip()

                log_file.write(f"{multi_split}\n")
                multi_split.remove(multi_split[0])
                multi_split.remove(multi_split[0])
                multi_split.insert(0, some_string)
            else:
                num = multi_split[0]

            # Addition ###############################
            add_split = num.split(" + ")
            log_file.write(f"+++{add_split}\n")

            for i in range(len(add_split)):
                add_split[i] = add_split[i].strip()
                add_split[i] = add_split[i].replace("~", "-")

            log_file.write(f"{add_split}\n")
            while len(add_split) != 1:
                one_value_list = add_split[0].split(" ")
                two_value_list = add_split[1].split(" ")

                try:
                    one_value_list.remove("")
                    two_value_list.remove("")
                except ValueError:
                    pass

                try:
                    one_value = int(one_value_list[-1])
                    two_value = int(two_value_list[0])
                except ValueError:
                    try:
                        one_value = float(one_value_list[-1])
                        two_value = float(two_value_list[0])
                    except ValueError:
                        if interactive:
                            print(f"< ! >: Some non-calculable value (\"{num}\") has been given.")
                            main()
                        else: exit(f"UCalc Excuses: Some non-calculable value (\"{num}\") has been given.")

                add_value = one_value + two_value
                two_value_list.remove(two_value_list[0])

                one_value_list[-1] = add_value.__str__()
                some_string = ""

                for each in one_value_list:
                    some_string += each + " "
                for each in two_value_list:
                    some_string += each + " "
                some_string = some_string.strip()

                log_file.write(f"{add_split}\n")
                add_split.remove(add_split[0])
                add_split.remove(add_split[0])
                add_split.insert(0, some_string)
            else:
                num = add_split[0]

            # Subtraction ##########################
            sub_split = num.split(" - ")
            log_file.write(f"---{sub_split}\n")

            for i in range(len(sub_split)):
                sub_split[i] = sub_split[i].replace("~", "-")
                sub_split[i] = sub_split[i].strip()

            log_file.write(f"{sub_split}\n")
            while len(sub_split) != 1:
                one_value_list = sub_split[0].split(" ")
                two_value_list = sub_split[1].split(" ")

                try:
                    one_value_list.remove("")
                    two_value_list.remove("")
                except ValueError:
                    pass
                log_file.write(f"{one_value_list}")
                log_file.write(f"{two_value_list}")
                log_file.write(f"{sub_split}")
                log_file.write(log)
                try:
                    one_value = int(one_value_list[-1])
                    two_value = int(two_value_list[0])
                except ValueError:
                    one_value = float(one_value_list[-1])
                    two_value = float(two_value_list[0])

                sub_value = one_value - two_value
                two_value_list.remove(two_value_list[0])

                one_value_list[-1] = sub_value.__str__()
                some_string = ""
                for each in one_value_list:
                    some_string += each + " "
                for each in two_value_list:
                    some_string += each + " "
                some_string = some_string.strip()

                log_file.write(f"{sub_split}\n")
                sub_split.remove(sub_split[0])
                sub_split.remove(sub_split[0])
                sub_split.insert(0, some_string)
            else:
                num = sub_split[0]

            return num


        def calculator_precedence(args):
            global log, log_file
            operator_list = ["+", "-", "/", "%", "^", "x", "*"]
            numbers_list = []
            # Separating Arithmetic Operators From Numbers Block
            for each in range(len(args)):
                if "?" in args[each] or "!" in args[each]:
                    args[each] = factorial(args[each])
                    log_file.write(f"Factorial: {args}\n")
                elif args[each].startswith("_") or args[each].startswith("√"):
                    args[each] = square_root(args[each])
                    log_file.write(f"SquareRoot: {args}\n")
                elif args[each].startswith(":"):
                    args[each] = cube_root(args[each])
                    log_file.write(f"SquareRoot: {args}\n")

            log_file.write(log)
            for each in args:
                log_file.write(f"{args} {numbers_list}\n")
                if each not in operator_list:
                    try:
                        each = int(each)
                    except ValueError:
                        try:
                            each = float(each)
                        except ValueError:
                            if each.startswith("~"):
                                compensation_each = each
                                each = each.replace("~", "-")
                                each = int(each)
                            else:
                                if interactive:
                                    print(f"""
< ! >: A non-calculable value({each}) has been given. Try --help for more information.""")
                                    main()
                                else: exit(f"""
UCalc Excuses: A non-calculable value({each}) has been given. Try --help for more information.""")

                    numbers_list.append(each)
                    try: args.remove(each.__str__())
                    except ValueError: args.remove(compensation_each.__str__())
                    log_file.write(f"OperaPrint: {args, numbers_list}\n")
            log_file.write(f"{args} {numbers_list}\n")
            log_file.write(f"Args 'n' nums{args, numbers_list}")


            # Calculation Block
            while True:
                log_file.write(f"CalcNumList: {numbers_list}, argsList: {args}\n")
                try:
                    if args[0] == "+":
                        value = numbers_list[0] + numbers_list[1]
                        numbers_list.remove(numbers_list[0])
                        numbers_list.remove(numbers_list[0])
                        numbers_list.insert(0, value)
                        args.remove(args[0])
                    elif args[0] == "-" or args[0] == "+~":
                        value = numbers_list[0] - numbers_list[1]
                        numbers_list.remove(numbers_list[0])
                        numbers_list.remove(numbers_list[0])
                        numbers_list.insert(0, value)
                        args.remove(args[0])
                    elif args[0] == "/":
                        value = numbers_list[0] / numbers_list[1]
                        numbers_list.remove(numbers_list[0])
                        numbers_list.remove(numbers_list[0])
                        numbers_list.insert(0, value)
                        args.remove(args[0])
                    elif args[0] == "%":
                        value = numbers_list[0] % numbers_list[1]
                        numbers_list.remove(numbers_list[0])
                        numbers_list.remove(numbers_list[0])
                        numbers_list.insert(0, value)
                        args.remove(args[0])
                    elif args[0] == "^" or args[0] == "**":
                        value = numbers_list[0] ** numbers_list[1]
                        numbers_list.remove(numbers_list[0])
                        numbers_list.remove(numbers_list[0])
                        numbers_list.insert(0, value)
                        args.remove(args[0])
                    elif args[0] == "x" or args[0] == "*":
                        value = numbers_list[0] * numbers_list[1]
                        numbers_list.remove(numbers_list[0])
                        numbers_list.remove(numbers_list[0])
                        numbers_list.insert(0, value)
                        args.remove(args[0])
                except IndexError:
                    break
            return str(numbers_list[0])


        # Bracket Handler Function
        def brackets(string):
            global log
            log_file.write(f"Entered Bracket Function with ({string})\n")
            string = string.replace("[", "|@")
            string = string.replace("]", "$|")
            log_file.write(f"Changed ({string}) and ({string.split('[')})\n")
            exists_brackets = True
            while True:
                if not "|" in string: break
                sep_list = string.split("|")
                for i in range( len(sep_list) ):
                    if sep_list[i].startswith("@") and sep_list[i].endswith("$"):
                        sep_list[i] = sep_list[i].replace("@", "")
                        sep_list[i] = sep_list[i].replace("$", "")
                        sep_list[i] = sep_list[i].replace("|", "")
                        if precedence:
                            try: sep_list[i] = calculator_precedence(sep_list[i].strip().split(" "))
                            except OverflowError:
                                if interactive:
                                    print("< EXCUSE >: The value is extreme to handle ")
                                    main()
                                else: exit("UCalc Excuses: The value is extreme to handle ")
                        else:
                            try: sep_list[i] = calculator_bodmas(sep_list[i].strip())
                            except OverflowError:
                                if interactive:
                                    print("< EXCUSE >: The value is extreme to handle ")
                                    main()
                                else: exit("UCalc Excuses: The value is extreme to handle ")
                        sep_list[i] = sep_list[i].replace("-", "~")
                        log_file.write(f"Returned: ({sep_list[i]})\n")
                string = ""
                for each in sep_list: string += each
                string = string.replace("@", "|@")
                string = string.replace("$", "$|")
            return string
        
        def formatted_square(num):
            high_prime = 0
            def is_prime(num):
                up_to = math.ceil(math.sqrt(num)) + 1
                is_prime = True
                for each in range(2, up_to):
                    if not each == num:
                        if num % each == 0:
                            is_prime = False
                            break
                        
                return is_prime

            try: num = int(num)
            except ValueError:
                if interactive:
                    print("< ! >: Not a numeric value to find formatted square-roots")
                    main()
                else: exit("UCalc Excuses: Not a numeric value to find formatted square-roots")

            factorés = ""
            i = 2
            while num != 1:
                if is_prime(i):
                    if i > high_prime: high_prime = i
                    if num % i == 0:
                        num = num / i
                        factorés += (str(i) + " ")
                        i = 2
                        continue
                i += 1

            outsqrt = 1
            insqrt = 1
            for each in range(1, high_prime + 1):
                pair = factorés.count(f"{each} {each}")
                factorés = factorés.replace(f"{each} {each}", "")
                if not pair == 0: outsqrt *= (each ** pair)
                if factorés.strip() == "": break
            factorés = factorés.strip()
            for each in factorés.split():
                insqrt *= int(each)
            
            if insqrt == 1: return f"{outsqrt}"
            else: return f"{outsqrt}·√{insqrt}"


        # misc_list for creating spaces before and after for chars inside the list
        misc_list = ["+", "-", "/", "÷", "%", "^", "x", "×", "*", "·", "{", "}", "[", "]", "(", ")"]
        # First item from sys.argv is removed for it is the name of program
        try:
            sys.argv.remove(sys.argv[0])
            log_file.write(f"System-arguments = {sys.argv}\n")
        except IndexError:
            pass

        temporary_string = ""
        temporary_two_string = ""
        for each in sys.argv:
            temporary_string += each
            temporary_two_string += each
        log_file.write(f"temporary_two_string = {temporary_two_string}\n")
        # Removing optional commas from input
        temporary_string = temporary_string.replace(",", "").strip()
        log_file.write(f"Single: {temporary_string}\n")
        
        def interactive_input_receiver(temporary_string):
            global readline
            temporary_string = input("< ASK >: ").strip()
            splitted_temporary_string = temporary_string.split(" ")
            temporary_string = ""
            for each in splitted_temporary_string:
                temporary_string += each
            temporary_string.replace(",", "")
            for each in misc_list:
                temporary_string = temporary_string.replace(each, f" {each} ")
            
            if temporary_string == "help":
                print(i_help_view)
                main()
            elif temporary_string == "about":
                print(about_view)
                main()
            elif temporary_string == "version":
                print(version_view)
                main()
            elif temporary_string == "constants":
                print(constant_view)
                main()
            elif temporary_string == "cc":
                print(simple_constant_view)
                main()
            elif temporary_string == "quit":
                exit("< QUIT >")

            return temporary_string    

        # Checking for options from the user
        if temporary_string == "--help" or temporary_string == "-h":
            print(help_view)
            exit()
        elif temporary_string == "--about" or temporary_string == "-ab":
            print(about_view)
            exit()
        elif temporary_string == "--version" or temporary_string == "-v":
            print(version_view)
            exit()
        elif temporary_string == "--constants" or temporary_string == "-c":
            print(constant_view)
            exit()
        elif temporary_string == "--constants-simple" or temporary_string == "-cc":
            print(simple_constant_view)
            exit()
        elif temporary_two_string == "-i" or temporary_two_string == "--interactive" or interactive:
            interactive = True
            temporary_string = interactive_input_receiver(temporary_string)
        
        # Checking extra inputs from the user

        # There will be a space between x and y because of
        # operator identification
        # In interactive the oprators are formatted before it is checked
        # for special inputs, thus, x y::
        called_xy_factoriser = False
        if "xy::" in temporary_string or "x y::" in temporary_string:
            log_file.write("### Passing on labour to XY factoriser ###\n")
            if not os.path.exists("xy"):
                log_file.write("### XY was not already compiled - first compilation ###\n")
                os.system(f"gcc {path_to_xy_c} -o {path_to_xy} -g -lgmp")
            temporary_string = temporary_string.replace("xy::", "")
            temporary_string = temporary_string.replace("x y::", "")
            find_xy_list = temporary_string.split("::")
            if len(find_xy_list) < 3:
                if interactive:
                    print("""
< ! >: There is insuffient arguments for finding the Product-Sum factor.
UCalc Exemplifies: xy::(Product)::(Sum)::(Counter Upto), xy::100::25::100
""")                
                    main()
                exit("""
UCalc Excuses: There is insuffient arguments for finding the Product-Sum factor.
UCalc Exemplifies: xy::(Product)::(Sum)::(Counter Upto), xy::100::25::100
""")
            if len(find_xy_list) > 3:
                if interactive:
                    print("< ! >: Redundant arguments while calling Product-Sum Factoriser.")
                    main()
                exit("UCalc Excuses: Redundant arguments while calling Product-Sum Factoriser.")
            if interactive: 
                os.system(f"{path_to_xy} {find_xy_list[0]} {find_xy_list[1]} {find_xy_list[2]} 1")
                log_file.write(f"{path_to_xy} {find_xy_list[0]} {find_xy_list[1]} {find_xy_list[2]} 1")
            else:
                os.system(f"{path_to_xy} {find_xy_list[0]} {find_xy_list[1]} {find_xy_list[2]} 0")
                log_file.write(f"{path_to_xy} {find_xy_list[0]} {find_xy_list[1]} {find_xy_list[2]} 0")
            temporary_string = "ans"
            called_xy_factoriser = True

        final_touch = ""
        precedence = False
        converter = "none"
        factorise = False
        prime_factorise = False
        frmt_sqrt = False
        negate = False
        if ".round" in temporary_string:
            temporary_string = temporary_string.replace(".round", "")
            final_touch = "round"
        elif ".ceil" in temporary_string:
            temporary_string = temporary_string.replace(".ceil", "")
            final_touch = "ceil"
        elif ".floor" in temporary_string:
            temporary_string = temporary_string.replace(".floor", "")
            final_touch = "floor"
        if ".precede" in temporary_string:
            temporary_string = temporary_string.replace(".precede", "")
            precedence = True
        if ".sqrt" in temporary_string:
            temporary_string = temporary_string.replace(".sqrt", "")
            frmt_sqrt = True
        if ".neg" in temporary_string:
            temporary_string = temporary_string.replace(".neg", "")
            negate = True

        types_of_converter = [".base64", ".hex", ".bin", ".oct", ".fromhex", ".frombin",
                              ".fromoct"]

        def extra_input_insurance(temporary_string):
            # Ensuring that there are no more than one converter call
            # Solely made with intention to integrate with converter calls
            for each in types_of_converter:
                temporary_string = temporary_string.replace(each, "")
            return temporary_string
        

        if ".base64" in temporary_string:
            temporary_string = temporary_string.replace(".base64", "")
            converter = "64"
        # In interactive mode, 'hex' becomes 'he x' due to
        # So, =>
        elif ".hex" in temporary_string or ".he x" in temporary_string:
            temporary_string = temporary_string.replace(".hex", "")
            temporary_string = temporary_string.replace(".he x", "")
            converter = "hex"
        elif ".bin" in temporary_string:
            temporary_string = temporary_string.replace(".bin", "")
            converter = "bin"
        elif ".oct" in temporary_string:
            temporary_string = temporary_string.replace(".oct", "")
            converter = "oct"
        elif ".ter" in temporary_string:
            temporary_string = temporary_string.replace(".ter", "")
            converter = "ter"
        elif ".from64" in temporary_string:
            temporary_string = temporary_string.replace(".from64", "")
            temporary_string = temporary_string.replace("ans", ans)
            temporary_string = extra_input_insurance(temporary_string)
            try:
                prompt_reply = Converters().reverse_base64(temporary_string)
            except ValueError:
                if interactive:
                    print("< ! >: You had either tried to do arithmetic operations or entered invalid base64 value.")
                    main()
                else: exit("UCalc Excuses: You had either tried to do arithmetic operations or entered invalid base64 value.")
            log_file.write("madeABaseSixtyFourPromptReply")
            log_file.write(ctime())
            log_file.write(log)

            if interactive:
                print(f"< REPLY >: Skipped everything and replied: {prompt_reply}")
                main()
            else: exit(f"UCalc has skipped everything and replied: {prompt_reply}")
        elif ".fromhex" in temporary_string or ".fromhe x" in temporary_string:
            temporary_string = temporary_string.replace(".fromhex", "")
            temporary_string = temporary_string.replace(".fromhe x", "")
            converter = "fromhex"
        elif ".frombin" in temporary_string:
            temporary_string = temporary_string.replace(".frombin", "")
            converter = "frombin"
        elif ".fromoct" in temporary_string:
            temporary_string = temporary_string.replace(".fromoct", "")
            converter = "fromoct"
        elif ".fromter" in temporary_string:
            temporary_string = temporary_string.replace(".fromter", "")
            converter = "fromter"
        if ".factor" in temporary_string or ".f" in temporary_string:
            factorise = True
            temporary_string = temporary_string.replace(".factor", "")
            temporary_string = temporary_string.replace(".f", "")
            if not os.path.exists(path_to_f):
                log_file.write("First f Compilation\n")
                os.system(f"gcc {path_to_f_c} -o {path_to_f} -g -lgmp -w")
            log_file.write("labour for f\n")
        if ".primes" in temporary_string or ".p" in temporary_string:
            prime_factorise = True
            log_file.write(f"prime_factorise: {prime_factorise}\n")
            temporary_string = temporary_string.replace(".primes", "")
            temporary_string = temporary_string.replace(".p", "")
            if not os.path.exists(path_to_pf):
                log_file.write("First pf compilation\n")
                os.system(f"gcc {path_to_pf_c} -o {path_to_pf} -g -lgmp -w")
            log_file.write("labour for pf\n")
        
        temporary_string = extra_input_insurance(temporary_string)
        # For adding the original expression with its answer
        along_with_answer = temporary_string

        for each in misc_list:
            temporary_string = temporary_string.replace(each, f" {each} ")
            temporary_string = temporary_string.replace("  ", " ")

        log_file.write(f"{temporary_string}\n")
        yet_another_list = temporary_string.split(" ")

        temp_string = ""
        for each in yet_another_list:
            temp_string += each + " "
            # Replacing To Uniform Symbols
            temp_string = temp_string.replace("{", "[")
            temp_string = temp_string.replace("}", "]")
            temp_string = temp_string.replace("(", "[")
            temp_string = temp_string.replace(")", "]")


            temp_string = temp_string.replace("*", "x")
            temp_string = temp_string.replace("·", "x")
            temp_string = temp_string.replace("×", "x")
            temp_string = temp_string.replace("÷", "/")

            # Special Values
            temp_string = temp_string.replace("ans", ans)
            temp_string = temp_string.replace("pi", (22 / 7).__str__())  # Pi
            temp_string = temp_string.replace("π", (22 / 7).__str__())  # Pi Littera Graecia
            temp_string = temp_string.replace("g", "9.8")  # Gravity of the Earth
            temp_string = temp_string.replace("G", (6.673 * 10 ** -11).__str__())  # Universal Gravitational Constant
            temp_string = temp_string.replace("R", "8.314")  # Universal Gas Constant
            temp_string = temp_string.replace("h", (6.62 * 10 ** -34).__str__())  # Planck's Constant
            temp_string = temp_string.replace("N", (6.022 * 10 ** 23).__str__()) # Avogadro's Number
            temp_string = temp_string.replace("k", (1.38 * 10 ** -23).__str__()) # Boltzmann Constant
            temp_string = temp_string.replace("F", (9.649 * 10 ** 4).__str__()) # Faraday Constant
            temp_string = temp_string.replace("c", (2.9979 * 10 ** 8).__str__()) # Speed Of Light In Vacuum

        # Checking for bracket equilibrium
        if temp_string.count("[") != temp_string.count("]"):
            if interactive:
                print("< ! >: There are incomplete brackets in the expression.")
                main()
            else: exit("UCalc Excuses: There are incomplete brackets in the expression.")

        # Very First Format Encounter
        temp_string = temp_string.replace("-", "+ ~")
        temp_string = temp_string.replace("e+ ~", "e-") # Avoiding errors from the above instruction
        temp_string = safety_formatting(temp_string)
        temp_string = brackets(temp_string)
        string = temp_string
        log_file.write("Trekked Brackets\n")

        string = string.strip()
        string = string.replace("--", "+")
        log_file.write(f"After Skirmish: {string}\n")

        # Implementing extra input from the user
        if precedence:
            try: reply = str( calculator_precedence( string.split(" ") ) )
            except OverflowError:
                if interactive:
                    print("< EXCUSE >: The value is extreme to handle ")
                    main()
                else: exit("UCalc Excuses: The value is extreme to handle ")
        else:
            try: reply = calculator_bodmas(string)
            except OverflowError:
                if interactive:
                    print("< EXCUSE >: The value is extreme to handle ")
                    main()
                else: exit("UCalc Excuses: The value is extreme to handle ")
        if final_touch == "round":
            reply = str( round( float(reply) ) )
            log_file.write("roundHasBeenCalled;fromPriorityOne\n")
        elif final_touch == "ceil":
            reply = str( math.ceil( float(reply) ) )
            log_file.write("ceilHasBeenCalled;fromPriorityTwo\n")
        elif final_touch == "floor":
            reply = str( math.floor( float(reply) ) )
            log_file.write("floorHasBeenCalled;fromPriorityThree\n")
        else:
            log_file.write("noSpecialInputUsed;fromNull\n")
        if negate:
            try: reply = str( -( int(reply) ) )
            except ValueError: reply = str( -( int(reply) ) ) 

        conversion = Converters()
        if converter == "64":
            reply = conversion.base64(reply.__str__())
            log_file.write("hasCalledUponBaseSixtyFourConverter\n")
        elif converter == "hex":
            reply = conversion.hexadecimal(reply.__str__())
            log_file.write("hasCalledUponHexDecimalConverter\n")
        elif converter == "oct":
            reply = conversion.octal(reply.__str__())
            log_file.write("hasCalledUponOctalConverter\n")
        elif converter == "ter":
            reply = conversion.ternary(reply.__str__())
            log_file.write("hasCalledUponTernaryConverter\n")
        elif converter == "bin":
            reply = conversion.binary(reply.__str__())
            log_file.write("hasCalledUponBinaryConverter\n")
        elif converter == "fromhex":
            reply = conversion.reverse_hexadecimal(reply.upper())
            log_file.write("hasCalledUponReverseHexDecimalConverter\n")
        elif converter == "fromoct":
            reply = conversion.reverse_octal(reply)
            log_file.write("hasCalledUponReverseOctalConverter\n")
        elif converter == "fromter":
            reply = conversion.reverse_ternary(reply)
            log_file.write("hasCalledUponReverseBinaryConverter\n")

        elif converter == "frombin":
            reply = conversion.reverse_binary(reply)
            log_file.write("hasCalledUponReverseBinaryConverter\n")
        else:
            log_file.write("proceedingWithDefaultBase\n")
        if frmt_sqrt:
            log_file.write("hasCalledFormattedSquareRoot\n")
            reply = formatted_square(reply)
        if prime_factorise:
            log_file.write("hasCalledPrimeFactorisation\n")
        
        reply = safety_formatting(reply)
        if interactive:
            if factorise: os.system(f"{path_to_f} {reply} 1")
            elif prime_factorise:  os.system(f"{path_to_pf} {reply} 1")
            else:
                if not called_xy_factoriser:
                    if not reply == '': print(f"< REPLY >: {reply}")
                    log_file.write(f"UCalc Replied: {along_with_answer} = {reply} @ {ctime()}\n")
                ending_time = time()
                total_time = ending_time - starting_time
                log_file.write(f"[END] in {total_time}")
            log_file.write(log)
            with open(path_to_ans, "w") as file: file.write(reply)
            main()

        else:
            if factorise: os.system(f"{path_to_f} {reply} 0")
            elif prime_factorise: os.system(f"{path_to_pf} {reply} 0")
            else:
                if not called_xy_factoriser:
                    if not reply == '': print(f"UCalc Replies: {reply}")
                    log_file.write(f"UCalc Replied: {along_with_answer} = {reply} @ {ctime()}\n")
                ending_time = time()
                total_time = ending_time - starting_time
                log_file.write(f"[END] in {total_time}")
                log_file.write(f"UCalc was liberated @ {ctime()} only employed for {total_time}")
                with open(path_to_ans, "w") as file: file.write(reply)

    except KeyboardInterrupt:
        ending_time = time()
        total_time = ending_time - starting_time
        log_file.write(f"UCalc was liberated @ {ctime()} only employed for {total_time}")
        log_file.write(log)
        log_file.close()
        exit("-- UCalc has been liberated --")
main()




